var documenterSearchIndex = {"docs":
[{"location":"base/#Common-functions","page":"Function list","title":"Common functions","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [AbstractSDRs]\nPages   = [\"AbstractSDRs.jl\"];\nOrder   = [:function, :type]\nDepth   = 1","category":"page"},{"location":"base/#AbstractSDRs.fullScale!-Union{Tuple{Array{Complex{T}, 1}}, Tuple{T}, Tuple{Array{Complex{T}, 1}, Any}} where T","page":"Function list","title":"AbstractSDRs.fullScale!","text":"Ensure that the input buffer has full scale, i.e the input is between -1 and + 1 This function  is inplace. This is usefull for radio that uses Int format, with input that should be normalized. 2 different policies \n\n:same : A common scaling factor is used for both I anbd Q path \n:independant : One scaling is used for real and one scaling is used for imag (default policy: :independent)\n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.getBufferSize-Tuple{Union{PlutoSDR, BladeRFBinding, RTLSDRBinding, RadioSim, SDROverNetwork, UHDBinding}}","page":"Function list","title":"AbstractSDRs.getBufferSize","text":"Returns the radio packet size. Each radio backend encapsulates the IQ samples into chunks of data. The recv command can be used with any size but it can be more efficient to match the desired size with the one provided by the radio \n\n–- Syntax\n\nbufferSize = getBufferSize(radio) \n\n–- Input parameters\n\nradio\t  : SDR device\n\n–- Output parameters\n\nbufferSize : Size of radio internal buffer \n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.getCarrierFreq-Tuple{Union{PlutoSDR, BladeRFBinding, RTLSDRBinding, RadioSim, SDROverNetwork, UHDBinding}}","page":"Function list","title":"AbstractSDRs.getCarrierFreq","text":"Get the current carrier frequency   of the radio device  The second parameter (optionnal) speicfies the Rx or Tx board (default : Rx)\n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.getGain-Tuple{Union{PlutoSDR, BladeRFBinding, RTLSDRBinding, RadioSim, SDROverNetwork, UHDBinding}}","page":"Function list","title":"AbstractSDRs.getGain","text":"Get the current radio gain  The second parameter (optionnal) specifies the Rx or Tx board (default : Rx)\n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.getSamplingRate-Tuple{Union{PlutoSDR, BladeRFBinding, RTLSDRBinding, RadioSim, SDROverNetwork, UHDBinding}}","page":"Function list","title":"AbstractSDRs.getSamplingRate","text":"Get the current sampling rate of the radio device  The second parameter (optionnal) speicfies the Rx or Tx board (default : Rx)\n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.getSupportedSDRs-Tuple{}","page":"Function list","title":"AbstractSDRs.getSupportedSDRs","text":"Returns an array of symbol which lists the supported SDR backends\n\n–- Syntax\n\nl = getSupportedSDR()\n\n–- Input parameters\n\n\n\n–- Output parameters\n\nl : Array of symbols of supported SDRs\n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.isClosed-Tuple{Union{PlutoSDR, BladeRFBinding, RTLSDRBinding, RadioSim, SDROverNetwork, UHDBinding}}","page":"Function list","title":"AbstractSDRs.isClosed","text":"Check if a SDR has already been closed. The falg is true is the SDR ressources have been released and false otherwise.\n\n–- Syntax\n\nflag = isClosed(radio) \n\n–- Input parameters\n\nradio\t  : SDR device\n\n–- Output parameters\n\nflag : True is SDR is already closed, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.openSDR-Tuple{Symbol, Vararg{Any, N} where N}","page":"Function list","title":"AbstractSDRs.openSDR","text":"Open a Software Defined Radio of backend 'type', tune accordingly based on input parameters and use the supported keywords. It returns a radio object, depending on the type of SDR that can be used with all AbstractSDRs supported functions\n\n–- Syntax\n\nradio = openSDR(type,carrierFreq,samplingRate,gain,antenna;key)\n\n–- Input parameters\n\ntype  : Desired SDR type. The different supported radio format can be obtained with getSupportedSDR();\ncarrierFreq : Carrier frequency [Hz]\nsamplingRate : Sampling frequency (Hz)\ngain : Analog Rx gain (dB)\n\n–- Output parameters\n\nradio : Defined SDR object\n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.recv!-Tuple{Any, SDROverNetwork, Vararg{Any, N} where N}","page":"Function list","title":"AbstractSDRs.recv!","text":"Receive from the SDR and fill them in the input buffer.\n\n–- Syntax\n\nnbSamples = recv!(sig,radio);\n\n–- Input parameters\n\nsig : Buffer to be filled\nradio : SDR device\n\n–- Output parameters\n\nnbSamples : Number of samples filled\n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.recv-Tuple{SDROverNetwork, Vararg{Any, N} where N}","page":"Function list","title":"AbstractSDRs.recv","text":"Receive nbSamples from the SDR and fill them in the output buffer. The buffer format depends on the SDR backend\n\n–- Syntax\n\nbuffer = recv(radio, nbSamples)\n\n–- Input parameters\n\nradio : SDR object\nnbSamples : Desired number of samples\n\n–- Output parameters\n\nbuffer : Output buffer from the radio filled with nbSamples samples\n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.scan","page":"Function list","title":"AbstractSDRs.scan","text":"Scan interface and returns the founded SDR \n\n–- Syntax\n\nsdr = scan()  sdr = scan(backend;key...)\n\nInput parameter\n\nIf the function is called without parameters il will search for all avaliable backends such as UHDBindings and AdalmPluto. Otherwise the search will be limited to the desired backend  The optionnal arguments are the one supported by UHDBindings and AdalmPluto. See uhd_find_devices() in UHDBindings and scan function in AdalmPluto \n\nKeywords\n\nargs : String used in UHD backend to specify USRP IP address. Example: scan(:uhd;args=\"addr=192.168.10.16\")\nbackend : Sring used in Pluto backend to specify the interface used (\"local\", \"xml\", \"ip\", \"usb\")\n\n\n\n\n\n","category":"function"},{"location":"base/#AbstractSDRs.updateCarrierFreq!-Tuple{SDROverNetwork, Vararg{Any, N} where N}","page":"Function list","title":"AbstractSDRs.updateCarrierFreq!","text":"Update carrier frequency of current radio device, and update radio object with the new obtained sampling frequency.\n\n–- Syntax\n\nupdateCarrierFreq!(radio,carrierFreq)\n\n–- Input parameters\n\nradio\t  : SDR device\ncarrierFreq\t: New desired carrier frequency\n\n–- Output parameters\n\ncarrierFreq : Effective carrier frequency\n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.updateGain!-Tuple{SDROverNetwork, Vararg{Any, N} where N}","page":"Function list","title":"AbstractSDRs.updateGain!","text":"Update gain of current radio device, and update radio object with the new obtained gain. If the input is a [UHDRx] or a [UHDTx] object, it updates only the Rx or Tx gain\n\n–- Syntax\n\nupdateGain!(radio,gain)\n\n–- Input parameters\n\nradio\t  : SDR device\ngain\t: New desired gain\n\n–- Output parameters\n\ngain : New gain value\n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.updateGainMode!-Tuple{Union{PlutoSDR, BladeRFBinding, RTLSDRBinding, RadioSim, SDROverNetwork, UHDBinding}}","page":"Function list","title":"AbstractSDRs.updateGainMode!","text":"Define Gain policy for the SDR radio. Only supported on AdalmPluto \n\n\n\n\n\n","category":"method"},{"location":"base/#AbstractSDRs.updateSamplingRate!-Tuple{SDROverNetwork, Vararg{Any, N} where N}","page":"Function list","title":"AbstractSDRs.updateSamplingRate!","text":"Update sampling rate of current radio device, and update radio object with the new obtained sampling frequency.\n\n–- Syntax\n\nupdateSamplingRate!(radio,samplingRate)\n\n–- Input parameters\n\nradio\t  : SDR device\nsamplingRate\t: New desired sampling rate\n\n–- Output parameters\n\nsamplingRate : Effective sampling rate\n\n\n\n\n\n","category":"method"},{"location":"Examples/example_parameters/#Update-parameters-of-the-radio","page":"Update parameters of the radio","title":"Update parameters of the radio","text":"","category":"section"},{"location":"Examples/example_parameters/","page":"Update parameters of the radio","title":"Update parameters of the radio","text":"It is possible to update the radio parameter such as the gain, the bandwidth and the sampling rate.  In this function, we change the carrier frequency to 2400MHz, the bandwidth from 16MHz to 100MHz and the Rx gain from 10 to 30dB. In some cases, the desired parameters cannot be obtained. In such a case, we let UHD decide what is the most appropriate value. A warning is raised and the output of the functions used to change the  the radio parameters corresponds to the effective values of the radio. ","category":"page"},{"location":"Examples/example_parameters/","page":"Update parameters of the radio","title":"Update parameters of the radio","text":"function main()\n\t# ---------------------------------------------------- \n\t# --- Physical layer and RF parameters \n\t# ---------------------------------------------------- \n\tcarrierFreq\t= 868e6; \t# --- The carrier frequency (Hz)\t\n\tsamplingRate\t= 16e6;         # --- Targeted bandwidth (Hz)\n\trxGain\t\t= 30.0;         # --- Rx gain (dB)\n\tnbSamples\t= 4096;         # --- Desired number of samples\n\n\t# ---------------------------------------------------- \n\t# --- Getting all system with function calls  \n\t# ---------------------------------------------------- \n\t# --- Creating the radio resource \n\tradio\t= openSDR(:uhd,carrierFreq,samplingRate,rxGain);\n\t# --- Display the current radio configuration\n\tprint(radio);\n\t# --- We what to change the parameters ! \n\tupdateSamplingFreq!(radio,100e6);\n\tupdateCarrierFreq!(radio,2400e6);\n\tupdateGain!(radio,30)\n\t# --- Print the new radio configuration \n\tprint(radio);\n\t# --- Release the radio resources\n\tclose(radio); \nend","category":"page"},{"location":"Examples/example_benchmark/#Benchmark-for-Rx-link","page":"Benchmark for Rx link","title":"Benchmark for Rx link","text":"","category":"section"},{"location":"Examples/example_benchmark/","page":"Benchmark for Rx link","title":"Benchmark for Rx link","text":"The following script allows to benchmark the effective rate from the receiver. To do so we compute the number of samples received in a given time. The timing is measured fro the timestamp obtained from the radio. ","category":"page"},{"location":"Examples/example_benchmark/","page":"Benchmark for Rx link","title":"Benchmark for Rx link","text":"module Benchmark \n# ---------------------------------------------------- \n# --- Modules & Utils\n# ---------------------------------------------------- \n# --- External modules \nusing UHDBindings \n# --- Functions \n\"\"\"\nCalculate rate based on UHD timestamp\n\"\"\"\nfunction getRate(tInit,tFinal,nbSamples)\n\tsDeb = tInit.intPart + tInit.fracPart;\n\tsFin = tFinal.intPart + tFinal.fracPart; \n\ttiming = sFin - sDeb; \n\treturn nbSamples / timing;\nend\n\"\"\"\nMain call to monitor Rx rate\n\"\"\"\nfunction main(samplingRate)\t\n\t# ---------------------------------------------------- \n\t# --- Physical layer and RF parameters \n\t# ---------------------------------------------------- \n\t# --- Create the radio object in function\n\tcarrierFreq\t\t= 770e6;\t\t\n\tgain\t\t\t= 50.0; \n\tradio\t\t\t= openSDR(:uhd,carrierFreq,samplingRate,gain); \n\t# --- Print the configuration\n\tprint(radio);\n\t# --- Init parameters \n\t# Get the radio size for buffer pre-allocation\n\tnbSamples \t\t= radio.packetSize;\n\t# We will get complex samples from recv! method\n\tsig\t\t  = zeros(Complex{Cfloat},nbSamples); \n\t# --- Targeting 2 seconds acquisition\n\t# Init counter increment\n\tnS\t\t  = 0;\n\t# Max counter definition\n\tnbBuffer  = 2*samplingRate;\n\t# --- Timestamp init \n\tp \t\t\t= recv!(sig,radio);\n\tnS\t\t\t+= p;\n\ttimeInit  \t= Timestamp(getTimestamp(radio)...);\n\twhile true\n\t\t# --- Direct call to avoid allocation \n\t\tp = recv!(sig,radio);\n\t\t# --- Ensure packet is OK\n\t\terr \t= getError(radio);\n\t\t# --- Update counter\n\t\tnS\t\t+= p;\n\t\t# --- Interruption \n\t\tif nS > nbBuffer\n\t\t\tbreak \n\t\tend\n\tend\n\t# --- Last timeStamp and rate \n\ttimeFinal = Timestamp(getTimestamp(radio)...);\n\t# --- Getting effective rate \n\tradioRate\t  = radio.samplingRate;\n    effectiveRate = getRate(timeInit,timeFinal,nS);\n\t# --- Free all and return\n\tclose(radio);\n\treturn (radioRate,effectiveRate);\n    end\nend","category":"page"},{"location":"#AbstractSDRs.jl","page":"Introduction to AbstractSDRs","title":"AbstractSDRs.jl","text":"","category":"section"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"(Image: )","category":"page"},{"location":"#Purpose","page":"Introduction to AbstractSDRs","title":"Purpose","text":"","category":"section"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"This package proposes a single API to monitor different kind of Software Defined Radio.  We define several SDR backends that can be piloted by the same API. With AbstractSDRs, the following SDRs can be used ","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"All Universal Software Radio Peripheral USRP, based on UHDBindings package\nRTL SDR dongle, with inclusion of RTLSDR package\nAny device connected to a remote PC with a network connection (for instance, Exxx USRP device) on which a Julia session works and run AbstractSDRs package.\nThe ADALM Pluto SDR, through a specific package (WIP) \nA pure simulation package usefull for testing without radio or do re-doing offline dataflow processing based on a given buffer ","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"AbstractSDRs provides an unified API to open, transmit and received samples and close the SDRs. ","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"For instance, in order to get 4096 samples at 868MHz with a instantaneous bandwidth of 16MHz, with a 30dB Rx Gain, assuming that a USRP is connected, the following Julia code will do the trick and returns a vector with type Complex{Cfloat} with 4096 samples.","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"function main()\n\t# ---------------------------------------------------- \n\t# --- Physical layer and RF parameters \n\t# ---------------------------------------------------- \n\n\tcarrierFreq\t\t= 868e6;\t# --- The carrier frequency \t\n\tsamplingRate\t\t= 16e6;         # --- Targeted bandwdith \n\trxGain\t\t\t= 30.0;         # --- Rx gain \n\tnbSamples\t\t= 4096;         # --- Desired number of samples\n\n\t# ---------------------------------------------------- \n\t# --- Getting all system with function calls  \n\t# ---------------------------------------------------- \n\t# --- Creating the radio ressource \n\t# The first parameter is to tune the Rx board\n\tradio\t= openSDR(\"UHDRx\",carrierFreq,samplingRate,rxGain);\n\t# --- Display the current radio configuration\n\tprint(radio);\n\t# --- Getting a buffer from the radio \n\tsig\t= recv(radio,nbSamples);\n\t# --- Release the radio ressources\n\tclose(radio); \n\t# --- Output to signal \n\treturn sig;\nend","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"Note that the SDR discrimination is done through the \"UHDRx\" parameter when opening the device, which states here that the UHD driver should be used, and that the radio will receive samples. To get the same functionnality with a RTL SDR dongle, the following code can be used.","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"function main()\n\t# ---------------------------------------------------- \n\t# --- Physical layer and RF parameters \n\t# ---------------------------------------------------- \n\n\tcarrierFreq\t\t= 868e6;\t# --- The carrier frequency \t\n\tsamplingRate\t\t= 16e6;         # --- Targeted bandwdith \n\trxGain\t\t\t= 30.0;         # --- Rx gain \n\tnbSamples\t\t= 4096;         # --- Desired number of samples\n\n\t# ---------------------------------------------------- \n\t# --- Getting all system with function calls  \n\t# ---------------------------------------------------- \n\t# --- Creating the radio ressource \n\t# The first parameter is to tune the Rx board\n\tradio\t= openSDR(\"RTLRx\",carrierFreq,samplingRate,rxGain);\n\t# --- Display the current radio configuration\n\tprint(radio);\n\t# --- Getting a buffer from the radio \n\tsig\t= recv(radio,nbSamples);\n\t# --- Release the radio ressources\n\tclose(radio); \n\t# --- Output to signal \n\treturn sig;\nend","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"Note that the only difference lies in the radio opening.","category":"page"},{"location":"#Installation","page":"Introduction to AbstractSDRs","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"pkg> add AbstractSDRs ","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"julia> import Pkg; Pkg.add(\"AbstractSDRs\")","category":"page"},{"location":"#Backends","page":"Introduction to AbstractSDRs","title":"Backends","text":"","category":"section"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"AbstractSDRs wraps and implements different SDR backends that can be used when opening a radio device. The current list of supported SDR backends can be obtained via getSupportedSDR.  When instantiate a radio device (with openSDR), the first argument is the radio backend and parameters associated to a specific backend can be used with keywords.  Some specific functions can also be exported based in the selected backend. The list is given in the sub-backend part  ","category":"page"},{"location":"#UHD-backend","page":"Introduction to AbstractSDRs","title":"UHD backend","text":"","category":"section"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"AbstractSDRs can be used with Universal Radio Peripheral (USRP) with the use of UHDBindings.jl package. The backend is identified by the symbol :uhd. This backend supports ths following keywords ","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"args=\"\" to specify any UHD argument in initialisation. Please refer to the UHD doc. For instance, FPGA bitstream path can be specified with args=\"fgpa=path/to/image.bit\". The IP address of the USRP can be added with args=\"addr=192.168.10.xx\".   ","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"AbstractSDRs package also exports the following specific functions","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"NONE. ","category":"page"},{"location":"#RadioSim","page":"Introduction to AbstractSDRs","title":"RadioSim","text":"","category":"section"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"This backend is useful when one wants to test a processing chain without having a radio as it simulates the behaviour of a SDR (configuration and buffer management). It is also useful when you have some acquisition in a given file (or buffer) as we can give the radio device a buffer which is then used to provide samples (as recv gives chunk of this buffer based on the desired size in a circular manner).      This backend supports ths following keywords","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"packetSize to specify the size of each packet given by the radio. By default the value is 1024 complex samples \nbuffer to give to the radio a buffer to be used when emulating the reception. The following rules occur \nIf packetSize is not given, the provided buffer will be buffer each time the recv command is used\nIf packetSize is higher than the size of the proposed buffer, the buffer will be circulary copied to provive packetSize complex samples \nIf packetSize is lower than the size of the proposed buffer, recv will returns packetSize samples from buffer and the buffer will be browsed cicularly \nIf no buffer is given, packetSize random data will be generated at the init of the radio and proposed each time recvis called","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"AbstractSDRs package also exports the following specific functions related to RadioSims","category":"page"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"updatePacketSize to update the size of the radio packet. \nupdateBuffer to update the radio buffer ","category":"page"},{"location":"#Pluto","page":"Introduction to AbstractSDRs","title":"Pluto","text":"","category":"section"},{"location":"","page":"Introduction to AbstractSDRs","title":"Introduction to AbstractSDRs","text":"This backend can be used with ADALM Pluto SDR device. ","category":"page"},{"location":"#SDROverNetworks","page":"Introduction to AbstractSDRs","title":"SDROverNetworks","text":"","category":"section"},{"location":"Examples/example_setup/#Set-up-a-Radio-Link-and-get-some-samples","page":"Set up a Radio Link and get some samples","title":"Set up a Radio Link and get some samples","text":"","category":"section"},{"location":"Examples/example_setup/","page":"Set up a Radio Link and get some samples","title":"Set up a Radio Link and get some samples","text":"We use a UHD based device. In order to get 4096 samples at 868MHz with a instantaneous bandwidth of 16MHz, with a 30dB Rx Gain, the following Julia code should do the trick. ","category":"page"},{"location":"Examples/example_setup/","page":"Set up a Radio Link and get some samples","title":"Set up a Radio Link and get some samples","text":"function main()\n\t# ---------------------------------------------------- \n\t# --- Physical layer and RF parameters \n\t# ---------------------------------------------------- \n\tcarrierFreq\t= 868e6; \t# --- The carrier frequency (Hz)\t\n\tsamplingRate\t= 16e6;         # --- Targeted bandwidth (Hz)\n\trxGain\t\t= 30.0;         # --- Rx gain (dB)\n\tnbSamples\t= 4096;         # --- Desired number of samples\n\n\t# ---------------------------------------------------- \n\t# --- Getting all system with function calls  \n\t# ---------------------------------------------------- \n\t# --- Creating the radio resource \n\tradio\t= openSDR(:uhd,carrierFreq,samplingRate,rxGain);\n\t# --- Display the current radio configuration\n\tprint(radio);\n\t# --- Getting a buffer from the radio \n\tsigAll\t= recv(radio,nbSamples);\n\t# --- Release the radio resources\n\tclose(radio); \nend","category":"page"},{"location":"Examples/example_mimo/#Example-of-MIMO-use-(with-UHD)","page":"Example of MIMO use (with UHD)","title":"Example of MIMO use (with UHD)","text":"","category":"section"},{"location":"Examples/example_mimo/","page":"Example of MIMO use (with UHD)","title":"Example of MIMO use (with UHD)","text":"Multiple antenna support is handled with the USRP (at least) based on the API proposed by UHD. Some extra parameters (channels, board and antennas) have to be set up according to the targeted board. The following example works for the USRP e310 and configure the radio to have its two receive antenna. The spectrum of the two channel is then depicted.  For other radio support, MIMO configuration should be modified to be compliant with the driver preriquisites. ","category":"page"},{"location":"Examples/example_mimo/","page":"Example of MIMO use (with UHD)","title":"Example of MIMO use (with UHD)","text":"# ----------------------------------------------------\n# --- Package dependencies \n# ---------------------------------------------------- \nusing AbstractSDRs \nusing Plots \nusing FFTW\n\n\n# ----------------------------------------------------\n# --- Radio parameters \n# ---------------------------------------------------- \nradioType   = :uhd      # We target UHDBindings here \ncarrierFreq = 2410e6     # Carrier frequency (ISM band)\nsamplingRate = 2e6      # Not high but issue with e310 stream :( \ngain        = 50        # In dB \n\n\n# ----------------------------------------------------\n# --- MIMO and board specificities \n# ---------------------------------------------------- \n# We need to specify the channels and the board as we use a USRP => Note that the way the parameters are set is based on how it is done at UHD level. You can have a look at the mimo example provided by UHD.\n# This may vary depending on the chosen hardware \n# /!\\ We need to specify how many antenna we want. Be sure that the configuration is handled by the hardware you have otherwise UHD will raise an error (and maybe segfault ?)\nnbAntennaRx = 2\nnbAntennaTx = 0\n# Antenna and board config\nchannels    = [0;1]     # First channel is the first path \nsubdev      = \"A:0 A:1\" # e310 board names \n# For the antenna, we need to specify the dictionnary of the allocated antenna for both Tx and Rx. In our case we will only do full Rx mode so we only specify the :Rx key \nantennas    = Dict(:Rx => [\"TX/RX\";\"RX2\"])\n\n# ----------------------------------------------------\n# --- Open radio \n# ---------------------------------------------------- \nradio = openSDR(\n                radioType,\n                carrierFreq,\n                samplingRate,\n                gain ;\n                nbAntennaTx, nbAntennaRx, \n                channels,\n                antennas,\n                subdev)\n\n\n# --- Receive a buffer\n# We specify the size of each buffer \n# We will have one buffer per channel so a Vector of Vector \n# sigVect[1] and sigVect[2] will have the same size (of nbSamples) each for a channel\nnbSamples = 4096 \nsigVect = recv(radio,nbSamples)\n\n\n# ----------------------------------------------------\n# --- Plot the spectrum \n# ---------------------------------------------------- \n# Get the rate from the radio using the accessor \ns = getSamplingRate(radio)\n# X axis \nxAx = ((0:nbSamples-1)./nbSamples .- 0.5) * s\n# PSD \ny = 10*log10.(abs2.(fftshift(fft(sigVect[1]))))\nplt = plot(xAx,y,label=\"First Channel\")\ny = 10*log10.(abs2.(fftshift(fft(sigVect[2]))))\nplot!(plt,xAx,y,label=\"Second Channel\")\nxlabel!(\"Frequency [Hz]\")\nylabel!(\"Magnitude [dB]\")\ndisplay(plt)\n\n\n# ----------------------------------------------------\n# --- Close radio \n# ---------------------------------------------------- \nclose(radio)","category":"page"}]
}
